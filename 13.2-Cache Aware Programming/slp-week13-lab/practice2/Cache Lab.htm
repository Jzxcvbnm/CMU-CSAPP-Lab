<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="zh-cn" xml:lang="zh-cn">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <meta name="keywords" content="Cache Lab " />
    <title>Cache Lab</title>
</head>

<body   class="mod-assignment course-49 dir-ltr lang-zh_cn_utf8" id="mod-assignment-view">

    <div id="content"><div id="intro" class="box generalbox generalboxcontent boxaligncenter">
      <h1 dir="ltr" style="margin-right: 0px">Cache Lab: Improving Program Locality</h1>
      <h3>INTRODUCTION</h3><p>This exercise deals with optimizing memory-intensive code. Image processing is one area that benefits greatly from such optimizations. </p><p>In this exercise we'll be optimizing two functions: <kbd>rotate</kbd>, a function designed to rotate an image 90 degrees clockwise, and <kbd>smooth</kbd>, a function designed to smooth (or more precisely to blur) an image. Your goal is to maximize the cache hit rate of these functions on a simulated L1 cache. We provide you with a cache simulator that simulates the performance of a computer's cache. </p><p>For our purposes, we will consider an image to be represented by a two-dimensional matrix M, where M<sub>i,j</sub> denotes the (<i>i</i>,<i>j</i>)th pixel of M. To simplify things, this assignment will deal only with square images. Rows and columns are numbered in zero-indexed fashion (like arrays), so rows and columns number from 0 to N-1, where N is the width/height of the image matrix. Pixel values consist of four 1-byte fields representing red, green, blue, and alpha.</p><h3>LOGISTICS</h3><p>The files needed for this assignment can be downloaded <a href="./cachelab.rar">here</a>. Once you've extracted the zip file to its own directory, you'll see a number of C source and header files:</p><p><table cellpadding="0" border="0"><tbody><tr><td width="25">  <br />
      </td><td width="140"><b>File:</b></td><td><b>Function:</b></td></tr><tr><td>  <br />
      </td><td><kbd>cache.c</kbd></td><td>Contains the code used for the cache simulation <br />
      </td></tr><tr><td>  <br />
      </td><td><kbd>cache.h</kbd></td><td>Header file for cache simulator <br />
      </td></tr><tr><td>  <br />
      </td><td><kbd>defs.h</kbd></td><td>Contains commonly used definitions and structures <br />
      </td></tr><tr>
      </tr><tr><td>  <br />
      </td><td><kbd>driver.c</kbd></td><td>The main program for testing various functions <br />
      </td></tr><tr><td>  <br />
      </td><td><kbd>rotate.c</kbd></td><td>Contains the rotate functions. You will modify this file. <br />
      </td></tr><tr><td>  <br />
      </td><td><kbd>smooth.c</kbd></td><td>Contains the smooth functions. You will modify this file. <br />
      </td></tr></tbody></table>
      <br />The only files you need to change, and the only files you will submit, are <kbd>rotate.c</kbd> and <kbd>smooth.c</kbd>. You're free to change the driver program as you see fit, but such changes won't be submissible. </p><h3>IMPLEMENTATION DETAILS</h3><h4>Data Representation:</h4><p></p><p>The fundamental data structure of our images is the <kbd>pixel</kbd> structure, shown below:</p><pre>typedef struct { </pre><blockquote dir="ltr" style="margin-right: 0px"><pre dir="ltr" style="margin-right: 0px"> unsigned short red : 8; </pre><pre dir="ltr" style="margin-right: 0px"> unsigned short green : 8; </pre><pre dir="ltr" style="margin-right: 0px"> unsigned short blue : 8; </pre><pre dir="ltr" style="margin-right: 0px"> unsigned short alpha : 8; </pre></blockquote><pre>} pixel; </pre><p>The structure definition above defines a 32-bit pixel, with 8 bits for each of the red, green, blue and alpha (opacity) components.</p><p>A two-dimensional square image of width <kbd>n</kbd> is stored in a one-dimensional array of <kbd>pixel</kbd>s; the (i, j)th pixel of the image is at <kbd>Img[PIXEL(i,j,n)]</kbd>, and <kbd>PIXEL</kbd> is defined as follows:</p><pre>#define PIXEL(i,j,n) ((i)* ( n )+(j))</pre><p>In order to use the cache simulator, we call it indirectly through use of the <kbd>COPY</kbd> and <kbd>SMOOTH</kbd> macros defined in <kbd>defs.h</kbd>. You <b>must</b> use these macros for doing your <kbd>COPY</kbd> and <kbd>SMOOTH</kbd> operations.</p><p>These are all defined in <kbd>defs.h</kbd>. </p><h3>Cache Structure:</h3><p>The cache we will be simulating is a 16 KB direct-mapped cache, with 32 byte cache lines. You may wish to refer back to the notes to determine how best to optimize for such a configuration.</p><h3>Rotate:</h3><p></p><p>The following C function takes a source image, <kbd>src</kbd>, of size <kbd>dim</kbd> x <kbd>dim</kbd> and puts a rotated copy into the destination image <kbd>dst</kbd>.</p><pre>void rotate_naive(int dim, pixel* src, pixel* dst) { </pre><blockquote dir="ltr" style="margin-right: 0px"><pre> int i, j; for(i=0; i&lt;dim; i++) { </pre><pre> for(j=0; j&lt;dim; j++) { </pre><blockquote dir="ltr" style="margin-right: 0px"><pre> COPY(&amp;dst[PIXEL(dim-1-j,i,dim)],&amp;src[PIXEL(i,j,dim)]); </pre></blockquote><pre> } </pre></blockquote><pre> } </pre><pre> return; </pre><pre>} </pre><p>This code traverses the rows of the source image, copying each into a column of the destination image. Your task is to try to maximize the number of cache hits by adjusting the algorithm to take advantage of the cache.</p><h3>Smooth:</h3><p></p><p>The following C function takes a source image of size <kbd>dim</kbd> x <kbd>dim</kbd> that is specified by <kbd>src</kbd>, and puts a 'smoothed' copy into the destination image <kbd>dst</kbd>. The actual smoothing is done by the <kbd>SMOOTH</kbd> macro, which takes in first the address of the destination pixel, and then the addresses of the source pixel and the 8 pixels surrounding it. For cases on the border of the image, <kbd>COPY</kbd> the pixel straight from the source to the destination, so as to not have to deal with the special case of not having 8 surrounding pixels. </p><pre>void smooth_naive(int dim, pixel *src, pixel *dst) { </pre><blockquote dir="ltr" style="margin-right: 0px"><pre> int i, j; </pre><pre> for(i=0; i&lt;dim;i++) { </pre><blockquote dir="ltr" style="margin-right: 0px"><pre> COPY(&amp;dst[PIXEL(i,0,dim)], &amp;src[PIXEL(i,0,dim)]); </pre><pre> COPY(&amp;dst[PIXEL(i,dim-1,dim)], &amp;src[PIXEL(i,dim-1,dim)]); </pre></blockquote><pre> } </pre><pre> for(j=1; j&lt;dim-1;j++) { </pre><blockquote dir="ltr" style="margin-right: 0px"><pre> COPY(&amp;dst[PIXEL(0,j,dim)], &amp;src[PIXEL(0,j,dim)]); </pre><pre> COPY(&amp;dst[PIXEL(dim-1,j,dim)], &amp;src[PIXEL(dim-1,j,dim)]); </pre></blockquote><pre> } </pre><pre> for(i=1; i&lt;dim-1; i++) { </pre><blockquote dir="ltr" style="margin-right: 0px"><pre> for(j=1; j&lt;dim-1; j++) { </pre><blockquote dir="ltr" style="margin-right: 0px"><pre> SMOOTH(&amp;dst[PIXEL(j,i,dim)], &amp;src[PIXEL(j,i,dim)], &amp;src[PIXEL(j-1,i,dim)], &amp;src[PIXEL(j+1,i,dim)], &amp;src[PIXEL(j,i+1,dim)], </pre><pre> &amp;src[PIXEL(j,i-1,dim)], &amp;src[PIXEL(j-1,i-1,dim)], &amp;src[PIXEL(j+1,i+1,dim)], &amp;src[PIXEL(j-1,i+1,dim)], &amp;src[PIXEL(j+1,i-1,dim)]); </pre></blockquote><pre> } </pre></blockquote><pre> } </pre><pre> return; </pre></blockquote><pre>} </pre><p>The code first takes care of the edge cases and does a straight copy for the border. It then traverses the image in standard fashion, smoothing each pixel as it comes. As with rotate, your goal is to maximize cache hitrate by improving locality.</p><h3>Evaluation:</h3><p>The improved algorithms you submit will be graded based on the cache simulator included in the zip file you downloaded earlier. Functions will be run on images of a number of different sizes (listed below), and for each size will be given a hitrate equal to the total number of cache hits divided by the number of cache attempts in the image. (Higher numbers are better.) A function's 'hit score' will be determined by taking the geometric mean (explained below) of the ratios produced by dividing your function's hitrate by the naive implementation's hitrate.</p>
      <p>For both rotate and smooth, a geometric mean of 5 numbers is computed by taking the 5th root of the product of those numbers, so for the five dimensions listed below the formula would be:<br /></p><center><b>hit score</b> = <b></b>(ratio<sub>64</sub> * ratio<sub>128</sub> * ratio<sub>256</sub> * ratio<sub>512</sub> * ratio<sub>1024</sub>)<sup>1/5</sup></center><p></p><h3>Assumptions:</h3><p></p><p>To make optimization easier, you may assume that the image dimensions will always be a multiple of 32. Your code must be able to correctly rotate for all dimensions that are multiples of 32, but your performance scores will be determined based solely upon the values listed below:</p><p></p><center><table border="1"><tbody><tr align="center"><td style="width: 10%">64 <br />
    </td><td style="width: 10%">128 <br />
    </td><td style="width: 10%">256 <br />
    </td><td style="width: 10%">512 <br />
    </td><td style="width: 10%">1024 <br />
    </td></tr></tbody></table></center><p></p><p><br /></p><h3>SETUP</h3><h4>Versioning</h4><p></p><p>The rotate.c and smooth.c that you unzip contain only two functions each: the original naive implementation of their respective function, and a &quot;register&quot; function. This function provides an easy way to compare multiple functions at the same time, and is called by the driver program before testing.</p><pre>void register_rotate_functions() { add_rotate_function(&amp;rotate, rotate_descr); } </pre><p>The function contains one or more calls to add_rotate_function. In the above example, add_rotate_function registers the function rotate along with a string rotate_descr which is an ASCII description of what the function does. See rotate.c to see how to create the string descriptions? The string can be at most 256 characters. The functions for smooth work analogously.</p><h4>Testing</h4><p>To test your functions, simply open the project file in Visual C++. Choosing Build, Execute will show the output of the driver program. (This is the same input that will be used for grading your submissions.).</p><p></p><h3>GRADING</h3><p>This is how grading for the exercise will work:</p><p></p><ul><li><p>Correctness: Your solutions must be 100% correct for any square image matrix with edge dimensions that are a multiple of 32. (The driver program will check correctness and will tell you if a particular implementation is incorrect.</p></li><li><p>Speed improvement: Your solutions will earn credit based on reaching a certain threshold, according to the tables below:</p></li></ul><center><table><tbody><tr><td width="30%"><b>Rotate:</b><table border="1"><tbody><tr><td width="100">Hit Score: <br />
          </td><td width="100">Credit: <br />
          </td></tr><tr align="center"><td>1.60 <br />
          </td><td>70/70 <br />
          </td></tr><tr align="center"><td>1.45 <br />
          </td><td>60/70 <br />
          </td></tr><tr align="center"><td>1.30 <br />
          </td><td>55/70 <br />
          </td></tr><tr align="center"><td>1.25 <br />
          </td><td>40/70 <br />
          </td></tr><tr align="center"><td>1.10 <br />
          </td><td>25/70 <br />
          </td></tr></tbody></table></td><td width="30%"><b>Smooth:</b><table border="1"><tbody><tr><td width="100">Hit Score: <br />
          </td><td width="100">Credit: <br />
          </td></tr><tr align="center"><td>1.30 <br />
          </td><td>30/30 <br />
          </td></tr><tr align="center"><td>1.25 <br />
          </td><td>25/30 <br />
          </td></tr><tr align="center"><td>1.20 <br />
          </td><td>20/30 <br />
          </td></tr><tr align="center"><td>1.15 <br />
          </td><td>15/30 <br />
          </td></tr><tr align="center"><td>1.10 <br />
          </td><td>10/30 <br />
          </td></tr></tbody></table></td></tr></tbody></table></center><h3>HINTS</h3><ul><li><p>The <kbd>rotate</kbd> function focuses on spatial locality: because each pixel is used only once, you should focus on using any pixels put into the cache by a previous pixel operation.</p></li><li><p>The <kbd>smooth</kbd> function benefits from spatial locality, but also reuses pixels it has read previously. Consequently, you should consider trying to improve temporal locality as well.</p></li><li><p>Try a large number of different functions. There is a <kbd>FIND_BEST_OF_MANY</kbd> #define flag in <kbd>driver.c</kbd> that can be used to find out which function provides the highest hit rate for each problem. </p></li><li><p>Just because your image is square doesn't mean you have to deal with the image in square pieces.</p></li><li><p>Remember the way things will be laid out in memory and how this affects what is put into the cache.</p></li></ul><!--/td--><!--/td--><!--/td--><!--/td--><!--/td--><!--/td--><!--/td--><!--/td--><!--/td--><!--/td--><!--/td--><!--/td--><!--/td--><h2>&nbsp;</h2></div></div>
</body>
</html>
